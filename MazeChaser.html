<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>è¿·å®«è¿½é€æˆ˜ (ç­–ç•¥ç‰ˆ)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: 'Inter', sans-serif;
        overflow: hidden; /* é˜²æ­¢æ»šåŠ¨æ¡å‡ºç° */
      }
      canvas {
        background-color: #2d3748; /* æ·±ç°è‰²èƒŒæ™¯ */
        display: block;
        border-radius: 0.5rem;
        box-shadow:
          0 10px 15px -3px rgba(0, 0, 0, 0.1),
          0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }
      .message-box {
        transition:
          opacity 0.5s ease-in-out,
          transform 0.5s ease-in-out;
      }
    </style>
  </head>
  <body
    class="flex min-h-screen flex-col items-center justify-center bg-gray-900 p-4 text-white"
  >
    <div class="mx-auto mb-2 w-full max-w-2xl text-center">
      <h1 class="text-4xl font-bold tracking-tight text-cyan-300">
        è¿·å®«è¿½é€æˆ˜
      </h1>
      <p class="mt-2 text-lg text-gray-400">é›†é½3é¢—æ°´æ™¶ï¼Œæ‰¾åˆ°å‡ºç°çš„å‡ºå£ï¼</p>
    </div>

    <div class="mb-3 flex items-center space-x-6 font-mono text-xl">
      <div id="timer" class="text-amber-400">æ—¶é—´: 0s</div>
      <div id="crystalCounter" class="text-cyan-400">æ°´æ™¶: 0 / 3</div>
    </div>

    <canvas id="mazeCanvas"></canvas>

    <!-- å¼€å§‹æ¸¸æˆç•Œé¢ -->
    <div
      id="startScreen"
      class="message-box fixed inset-0 flex items-center justify-center bg-black bg-opacity-80"
    >
      <div class="text-center">
        <h2 class="mb-4 text-5xl font-bold text-white">å‡†å¤‡å¥½äº†å—ï¼Ÿ</h2>
        <p class="mb-8 text-xl text-gray-300">ç”¨æ–¹å‘é”®ç§»åŠ¨ ğŸ°ï¼Œèº²å¼€ ğŸ‘»</p>
        <button
          id="startButton"
          class="transform rounded-lg bg-cyan-500 px-8 py-3 text-2xl font-bold text-white transition duration-300 hover:scale-105 hover:bg-cyan-600"
        >
          å¼€å§‹æ¸¸æˆ
        </button>
      </div>
    </div>

    <!-- è·èƒœæ¶ˆæ¯æç¤ºæ¡† -->
    <div
      id="winMessage"
      class="message-box pointer-events-none fixed inset-0 flex scale-95 transform items-center justify-center bg-black bg-opacity-75 opacity-0"
    >
      <div
        class="rounded-lg border border-green-500 bg-gray-800 p-8 text-center shadow-2xl"
      >
        <h2 class="mb-4 text-3xl font-bold text-green-400">ä½ æˆåŠŸäº†ï¼</h2>
        <p class="mb-6 text-gray-300">å¤ªæ£’äº†ï¼Œä½ æˆåŠŸç”©æ‰äº†å°å¹½çµï¼</p>
        <button
          id="restartButtonWin"
          class="rounded-lg bg-cyan-500 px-6 py-2 font-bold text-white transition duration-300 hover:bg-cyan-600"
        >
          å†ç©ä¸€æ¬¡
        </button>
      </div>
    </div>

    <!-- æ¸¸æˆç»“æŸæ¶ˆæ¯æç¤ºæ¡† -->
    <div
      id="gameOverMessage"
      class="message-box pointer-events-none fixed inset-0 flex scale-95 transform items-center justify-center bg-black bg-opacity-75 opacity-0"
    >
      <div
        class="rounded-lg border border-red-500 bg-gray-800 p-8 text-center shadow-2xl"
      >
        <h2 class="mb-4 text-3xl font-bold text-red-500">æ¸¸æˆç»“æŸï¼</h2>
        <p class="mb-6 text-gray-300">ä½ è¢«æŠ“ä½äº†ï¼ä¸‹æ¬¡å¥½è¿ï¼</p>
        <button
          id="restartButtonGameOver"
          class="rounded-lg bg-red-500 px-6 py-2 font-bold text-white transition duration-300 hover:bg-red-600"
        >
          å†è¯•ä¸€æ¬¡
        </button>
      </div>
    </div>

    <script>
      // --- æ¸¸æˆè®¾ç½® ---
      const canvas = document.getElementById('mazeCanvas');
      const ctx = canvas.getContext('2d');
      const startScreen = document.getElementById('startScreen');
      const startButton = document.getElementById('startButton');
      const winMessage = document.getElementById('winMessage');
      const gameOverMessage = document.getElementById('gameOverMessage');
      const restartButtonWin = document.getElementById('restartButtonWin');
      const restartButtonGameOver = document.getElementById(
        'restartButtonGameOver'
      );
      const timerDisplay = document.getElementById('timer');
      const crystalCounterDisplay = document.getElementById('crystalCounter');

      let maze, player, exit, monster, crystals;
      let mazeSize, tileSize;
      const totalCrystals = 3;
      let collectedCrystals = 0;
      let gameStarted = false;
      let gameOver = false;
      let timerInterval, monsterMoveInterval, startTime;
      let animationFrameId;

      // --- æ ¸å¿ƒåŠŸèƒ½ ---

      function init() {
        // åœæ­¢æ‰€æœ‰æ­£åœ¨è¿è¡Œçš„æ¸¸æˆå¾ªç¯å’Œè®¡æ—¶å™¨
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        clearInterval(timerInterval);
        clearInterval(monsterMoveInterval);

        // é‡ç½®æ¸¸æˆçŠ¶æ€
        gameStarted = false;
        gameOver = false;
        collectedCrystals = 0;

        mazeSize = 19;

        const screenWidth = window.innerWidth * 0.9;
        const screenHeight = window.innerHeight * 0.7;

        tileSize = Math.floor(
          Math.min(screenWidth / mazeSize, screenHeight / mazeSize)
        );
        if (tileSize < 16) tileSize = 16;

        canvas.width = mazeSize * tileSize;
        canvas.height = mazeSize * tileSize;

        maze = generateLoopyMaze(mazeSize, mazeSize, 0.15);

        player = { x: 1, y: 1, jumpOffset: 0 };
        monster = { x: mazeSize - 2, y: 1 };
        exit = null;

        placeCrystals();
        updateCrystalCounter();
        timerDisplay.textContent = `æ—¶é—´: 0s`;

        // éšè—æ¶ˆæ¯æ¡†ï¼Œæ˜¾ç¤ºå¼€å§‹å±å¹•
        winMessage.classList.add(
          'opacity-0',
          'pointer-events-none',
          'transform',
          'scale-95'
        );
        gameOverMessage.classList.add(
          'opacity-0',
          'pointer-events-none',
          'transform',
          'scale-95'
        );
        startScreen.classList.remove('opacity-0', 'pointer-events-none');

        draw(); // ç»˜åˆ¶åˆå§‹çš„æ¸¸æˆç”»é¢
      }

      function startGame() {
        if (gameStarted) return;
        gameStarted = true;
        gameOver = false;

        // éšè—å¼€å§‹å±å¹•
        startScreen.classList.add('opacity-0', 'pointer-events-none');

        // å¯åŠ¨è®¡æ—¶å™¨å’Œæ€ªç‰©
        startTimer();
        startMonster();
        gameLoop();
      }

      function generateLoopyMaze(width, height, loopFactor = 0.1) {
        let grid = Array.from({ length: height }, () => Array(width).fill(1));
        const stack = [];
        grid[1][1] = 0;
        stack.push([1, 1]);

        while (stack.length > 0) {
          const [cx, cy] = stack[stack.length - 1];
          const directions = [
            [0, -2],
            [2, 0],
            [0, 2],
            [-2, 0],
          ];
          directions.sort(() => Math.random() - 0.5);
          const neighbors = [];

          for (const [dx, dy] of directions) {
            const nx = cx + dx,
              ny = cy + dy;
            if (
              nx > 0 &&
              nx < width - 1 &&
              ny > 0 &&
              ny < height - 1 &&
              grid[ny][nx] === 1
            ) {
              neighbors.push([nx, ny]);
            }
          }

          if (neighbors.length > 0) {
            const [nx, ny] = neighbors[0];
            grid[ny][nx] = 0;
            grid[cy + (ny - cy) / 2][cx + (nx - cx) / 2] = 0;
            stack.push([nx, ny]);
          } else {
            stack.pop();
          }
        }

        for (let y = 1; y < height - 1; y++) {
          for (let x = 1; x < width - 1; x++) {
            if (grid[y][x] === 1) {
              if (Math.random() < loopFactor) {
                grid[y][x] = 0;
              }
            }
          }
        }
        return grid;
      }

      function placeCrystals() {
        crystals = [];
        const emptyCells = [];
        for (let y = 1; y < mazeSize - 1; y++) {
          for (let x = 1; x < mazeSize - 1; x++) {
            if (maze[y][x] === 0) {
              emptyCells.push({ x, y });
            }
          }
        }

        for (let i = 0; i < totalCrystals; i++) {
          if (emptyCells.length === 0) break;
          const randomIndex = Math.floor(Math.random() * emptyCells.length);
          const cell = emptyCells.splice(randomIndex, 1)[0];
          if (
            (cell.x !== player.x || cell.y !== player.y) &&
            (cell.x !== monster.x || cell.y !== monster.y)
          ) {
            crystals.push(cell);
          } else {
            i--;
          }
        }
      }

      function spawnExit() {
        const emptyCells = [];
        for (let y = 1; y < mazeSize - 1; y++) {
          for (let x = 1; x < mazeSize - 1; x++) {
            if (maze[y][x] === 0 && (x !== player.x || y !== player.y)) {
              emptyCells.push({ x, y });
            }
          }
        }
        if (emptyCells.length > 0) {
          exit = emptyCells[Math.floor(Math.random() * emptyCells.length)];
        } else {
          exit = { x: mazeSize - 2, y: mazeSize - 2 };
        }
      }

      function gameLoop() {
        if (gameOver) return;
        draw();
        if (player.jumpOffset > 0) player.jumpOffset -= 1.5;
        if (player.jumpOffset < 0) player.jumpOffset = 0;
        animationFrameId = requestAnimationFrame(gameLoop);
      }

      function draw() {
        ctx.fillStyle = '#2d3748';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#6b46c1';
        for (let y = 0; y < mazeSize; y++) {
          for (let x = 0; x < mazeSize; x++) {
            if (maze[y][x] === 1) {
              ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
            }
          }
        }

        ctx.font = `${tileSize * 0.8}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        crystals.forEach((crystal) => {
          ctx.fillText(
            'ğŸ’',
            crystal.x * tileSize + tileSize / 2,
            crystal.y * tileSize + tileSize / 2
          );
        });

        if (exit) {
          ctx.fillText(
            'ğŸŒŸ',
            exit.x * tileSize + tileSize / 2,
            exit.y * tileSize + tileSize / 2
          );
        }

        // ä½¿ç”¨æ–°çš„å¹½çµå›¾æ ‡
        ctx.fillText(
          'ğŸ‘»',
          monster.x * tileSize + tileSize / 2,
          monster.y * tileSize + tileSize / 2
        );

        const playerYPos =
          player.y * tileSize + tileSize / 2 - player.jumpOffset;
        ctx.fillText('ğŸ°', player.x * tileSize + tileSize / 2, playerYPos);
      }

      function findPathBFS(startNode, endNode) {
        const queue = [[startNode.x, startNode.y]];
        const visited = new Set([`${startNode.x},${startNode.y}`]);
        const parentMap = new Map();

        while (queue.length > 0) {
          const [cx, cy] = queue.shift();
          if (cx === endNode.x && cy === endNode.y) {
            const path = [];
            let current = endNode;
            while (current) {
              path.unshift(current);
              current = parentMap.get(`${current.x},${current.y}`);
            }
            return path;
          }
          const directions = [
            [0, 1],
            [0, -1],
            [1, 0],
            [-1, 0],
          ];
          for (const [dx, dy] of directions) {
            const nx = cx + dx,
              ny = cy + dy;
            const key = `${nx},${ny}`;
            if (
              nx >= 0 &&
              nx < mazeSize &&
              ny >= 0 &&
              ny < mazeSize &&
              maze[ny][nx] === 0 &&
              !visited.has(key)
            ) {
              visited.add(key);
              parentMap.set(key, { x: cx, y: cy });
              queue.push([nx, ny]);
            }
          }
        }
        return null;
      }

      function moveMonster() {
        const path = findPathBFS(
          { x: monster.x, y: monster.y },
          { x: player.x, y: player.y }
        );
        if (path && path.length > 1) {
          monster.x = path[1].x;
          monster.y = path[1].y;
        }
      }

      function startTimer() {
        startTime = Date.now();
        clearInterval(timerInterval);
        timerInterval = setInterval(() => {
          if (!gameOver) {
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            timerDisplay.textContent = `æ—¶é—´: ${elapsedTime}s`;
          }
        }, 1000);
      }

      function startMonster() {
        clearInterval(monsterMoveInterval);
        monsterMoveInterval = setInterval(() => {
          if (!gameOver) {
            moveMonster();
            checkGameOver();
          }
        }, 550);
      }

      function handleKeyPress(e) {
        if (!gameStarted || gameOver) return;

        let dx = 0,
          dy = 0;
        switch (e.key) {
          case 'ArrowUp':
            dy = -1;
            break;
          case 'ArrowDown':
            dy = 1;
            break;
          case 'ArrowLeft':
            dx = -1;
            break;
          case 'ArrowRight':
            dx = 1;
            break;
          default:
            return;
        }
        e.preventDefault();

        const nextX = player.x + dx;
        const nextY = player.y + dy;

        if (
          nextX >= 0 &&
          nextX < mazeSize &&
          nextY >= 0 &&
          nextY < mazeSize &&
          maze[nextY][nextX] === 0
        ) {
          player.x = nextX;
          player.y = nextY;
          player.jumpOffset = tileSize / 3;
          checkCrystalCollection();
          checkWinCondition();
          checkGameOver();
        }
      }

      function updateCrystalCounter() {
        crystalCounterDisplay.textContent = `æ°´æ™¶: ${collectedCrystals} / ${totalCrystals}`;
      }

      function checkCrystalCollection() {
        const crystalIndex = crystals.findIndex(
          (c) => c.x === player.x && c.y === player.y
        );
        if (crystalIndex > -1) {
          crystals.splice(crystalIndex, 1);
          collectedCrystals++;
          updateCrystalCounter();
          if (collectedCrystals === totalCrystals) {
            spawnExit();
          }
        }
      }

      function stopGame(isWin) {
        if (gameOver) return;
        gameOver = true;
        clearInterval(timerInterval);
        clearInterval(monsterMoveInterval);
        if (isWin) {
          winMessage.classList.remove(
            'opacity-0',
            'pointer-events-none',
            'transform',
            'scale-95'
          );
        } else {
          gameOverMessage.classList.remove(
            'opacity-0',
            'pointer-events-none',
            'transform',
            'scale-95'
          );
        }
      }

      function checkWinCondition() {
        if (exit && player.x === exit.x && player.y === exit.y) {
          stopGame(true);
        }
      }

      function checkGameOver() {
        if (player.x === monster.x && player.y === monster.y) {
          stopGame(false);
        }
      }

      // --- äº‹ä»¶ç›‘å¬ ---
      startButton.addEventListener('click', startGame);
      window.addEventListener('keydown', handleKeyPress);
      restartButtonWin.addEventListener('click', init);
      restartButtonGameOver.addEventListener('click', init);
      window.addEventListener('resize', init);

      // --- æ¸¸æˆå¯åŠ¨ ---
      init();
    </script>
  </body>
</html>
